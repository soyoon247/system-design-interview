# 채팅 시스템 설계

## 채팅서비스의 기능
- 클라이언트들로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자가 접속 상태가 아닌 경우에는 접속할 때까지 해당 메시지 보관

송신 클라이언트는 수신 클라이언트에게 전달할 메시지를 채팅 서비스에 보낼 때 HTTP 프로토콜을 이용한다. keep-alive 헤더를 사용하여 클라이언트-서버 연결을 유지, TCP 접속 과정에서의 핸드셰이크 횟수를 줄임.
but,
HTTP는 클라이언트가 연결을 만드는 프로토콜이므로, 서버가 연결을 만드는 것처럼 동작하기 위한 기법들이 있었음. 
- 폴링
    - 클라이언트가 주기적으로 서버에게 메시지 있냐고 물어봄. 
    - 불필요한 서버 자원 낭비
- 롱 폴링
    - 클라이어느는 새 메시지가 반환되거나 타임아웃 때까지 연결을 유지
    - 새 메시지를 받으면 기존 연결 종료하고 다시 새로운 요청을 보냄. 
    - 보통 무상태서버기 때문에 송신 클라이언트와 수신 클라이언트가 같은 채팅 서버에 접속했다는 보장이 없다. 
- 웹 소켓
    - 서버가 클라이언트에게 비동기 메시지를 보낼 때 가장 널리 사용하는 기술
    - 웹 소켓 연결은 클라이언트가 시작. 영구적이고 양방향 연결
    - 처음에는 HTTP 연결로 시작, 특정 핸드셰이크 절차를 거쳐 웹 소켓 연결로 업그레이드된다. 이 연결 이후에는 서버가 클라이언트에 비동기적으로 메시지 전송이 가능하다. 
    - 서버 측에서 연결 관리를 효율적으로 해야 함. 

## 채팅 서비스의 구성
### 무상태 서비스
- 채팅이 아닌 전통적인 요청/응답 서비스. (로그인, 회원가입, 프로필 확인 등)
- 여기에 클라이언트가 접속할 채팅 서버의 DNS 호스트명을 클라이언트에게 알려주는 역할을 하는 **서비스 탐색 서비스**가 있다. 
### 상태 유지 서비스
- 채팅 서비스는 상태 유지가 필요함
### 제 3자 연동 서비스
- 푸시 알림

### 규모 확장성
- 로드밸런서를 통하는 API 서버, 알림 서버
- 웹소켓을 통해 실시간으로 연결되는 채팅 서버, 접속 상태 서버가
- 키값 저장소에 채팅 이력을 저장
- 서버 한 대로는 충분하지 않음

### 저장소
채팅 시스템이 다루는 데이터는 보통 두 가지
- 사용자 프로파일, 설정, 친구 목록 등 -> 관계형 디비(안정성 보장)
- 채팅 이력 -> 키-값 저장소
    - 수평적 규모 확장이 쉽다. 
    - 데이터 접근 지연시간이 낮다
    - 관계형 디비는 데이터의 롱 테일 부분을 잘 처리하지 못한다. (인덱스가 커지면 무작위적 접근에 대한 비용이 늘어난다)
    - 많은 안정적인 채팅 서비스가 키-값 저장소를 사용중이다.

    
    ```
    채팅 이력의 읽기.쓰기 연산 패턴 이해하기
    - 방대한 데이터 양
    - 빈번하게 사용되는 것은 최근 메시지, 오래된 메시지는 보지 않음
    - 검색 등을 통해 무작위적 데이터 접근을 하게 될 수도 있다
    - 1대 1 앱의 경우 읽기:쓰기 비율이 1:1이다.
    ```

### 데이터 모델
- 1:1 채팅 : 기본키는 message_id
- 그룹 채팅 : channel_id, message_id 의 복합 키를 기본 키로, channel_id는 파티션 키로도 사용
- 메시지ID는 고유하고, 정렬 가능, 시간 순서와 일치해야 한다. 
    - NoSQL에서는 스노플레이크같은 방법을 사용하여 ID 생성할 수 있다. 
    - 같은 그룹 내에서만 아이디가 유일하면 되기 때문에 전역적으로 고유하지 않아도 된다. 


## 상세 설계
### 서비스 탐색
- 클라이언트에게 가장 적합한 채팅 서버를 추천 : 클라이언트의 위치, 서버의 용량 등의 기준으로
- 아파치 주키퍼 

### 1:1 채팅 메시지 흐름
- 사용자 A가 채팅서버1을 통해 보낸 메시지는 메시지 동기화 큐로 전송된다
- 키-값 저장소에 보관된다
- 사용자 B가 접속중이라면 접속 중인 채팅 서버를 통해 전송된다
- 사용자 B가 부재중이라면 푸시알림 서버로 보낸다

### 여러 단말 사이의 메시지 동기화
- 단말에 cur_max_message_id 를 별도로 저장하고, 메시지ID가 그 값보다 크면 새 메시지로 간주한다. 

### 소규모 그룹 채팅 메시지 흐름
- A가 보낸 메시지가 사용자 B와 C의 메시지 동기화 큐에 복사된다. (큐 = 각각 할당된 메시지 수신함 같은 역할)
- 그룹이 크지 않을 때는 수신자 별로 복사해서 큐에 넣는 비용이 문제되지 않음
- 많은 사용자를 지원해야 하는 경우, 좋지는 않다. 
- 대규모 그룹 채팅의 경우는? 
  - 채팅 그룹의 모든 사용자 메시지 큐에 개별적으로 복사하는 게 아니라, 메시지를 중앙 집중화된 메시지 브로커를 통해 발행(Publish)하고, 이를 구독(Subscribe)하는 사용자들이 비동기적으로 수신할 수 있도록?


### 접속상태 표시 
- 웹소켓으로 통신하는 실시간 서비스의 일부임
- 로그인하고 웹소켓 연결이 맺어지고 나면 접속상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 보관
- 로그아웃하면 상태를 offline 으로 변경

### 접속 장애
- heartbeat 검사를 통해 장애 상황에서 접속 상태를 반영한다. 
- 클라이언트가 주기적으로 박동 이벤트를 보내고, x초 이내에 또 다른 이벤트를 받으면 사용자의 접속 상태를 온라인으로 유지

### 상태 정보의 전송
- pub-sub 모델 사용
- 각각의 친구 관계마다 채널을 두고, 사용자의 상태가 변경되면 각각의 채널들이 구독하고 있어서 상태 변화를 알 수 있게 된다. 
- 그룹의 크기가 클 때는 비용이 많이 들게 되어 좋지 않고, 사용자가 그룹 채팅에 입장하는 순간에만 상태 정보를 읽어가게 하거나, 수동으로 갱신하도록 유도하는 방법을 쓴다.






