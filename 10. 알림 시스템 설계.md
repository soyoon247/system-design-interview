
# 알림 시스템 설계

- 고객에게 중요한 정보를 비동기적으로 제공
- 모바일 푸시 알림, SMS 메시지, 이메일

### 알림 유형별 지원 방안
- ios 푸시 알림 : 알림 제공자 -> APNS (애플이 제공하는 원격 서비스) -> 단말
- 안드로이드 푸시 알림 : 알림 제공자 -> FCM -> 단말
- SMS 메시지 : 트윌리오, 넥스모 등 제 3 사업자 (유료)
- 이메일 : 알림 제공자 -> 이메일 서비스 -> 단말 (유료 서비스 또는 직접 구축)

### 연락처 정보 수집 절차
계정 등록 시 데이터베이스에 저장

### 알림 전송 및 수신 절차
**초기 설계안** 

- 서비스 -> 알림 시스템(알림 전송 API 제공, 알림 페이로드 생성) -> 제 3자 서비스(실제로 유저에게 알림을 전달) 

위 설계의 문제점 
- SPOF : 알림 서비스에 서버가 하나라서 서버에 장애가 생기면 전체 서비스에 장애
- 확장성
- 성능 병목 : 한 서버에서 모두 처리하므로 트래픽 몰릴 때는 과부하


**개선된 설계안**
- 데이터베이스와 캐시를 알림 시스템의 주 서버에서 분리
- 알림 서버를 증설(수평적 규모 확장)
- 메시지 큐 이용

### 안정성 확보
- 데이터 손실 방지 : 알림은 지연되거나 순서가 틀려도 되지만, 소실되는 것은 안됨. -> 알림 데이터를 디비에 보관하고 재시도 메커니즘을 구현해야 함. 
- 알림 중복 전송 방지 : 중복을 완전히 막는 것은 불가능함 ([참고 링크](https://bravenewgeek.com/you-cannot-have-exactly-once-delivery/)). but 알림 이벤트 ID를 검사하여 중복된 이벤트인지 살피고 아닐 경우 발송하도록 최대한 노력.

- kafka로 알아본 내용
  - producer -> broker, consumer -> offset commit 두 케이스 모두 
    - 수신 여부를 확실하게 하고자 할 때는 시간이 지연되고, 그 과정에서 네트워크 장애 등으로 알림이 누락될 수 있고(그래서 실패 시 다시 전송할 수도 있지만, 이건 엄밀한 의미에서 exactly-once 가 아닌..),
    - 수신 여부의 정확도를 낮추고 수신되었다고 판단해버리면, 실제로 수신을 못했을 경우가 있기 때문에 알림이 누락될 수 있다.
    - 시스템 전반적으로 안정성 확보, 중복 방지 처리가 되어야 하므로 실제로는 거의 불가능.  
    - [참고1](https://huisam.tistory.com/entry/kafka-message-semantics)
    - [참고2](https://www.joinc.co.kr/w/man/12/Kafka/exactlyonce)
    - [참고3](https://dhkdn9192.github.io/apache-kafka/kakfa-exactly-once-delivery/)

### 알림 템플릿
유사한 알림 형식, 메시지를 모두 새로 만들 필요가 없도록 함.

### 알림 설정
알림 설정 테이블에 보관 (channel, opt_in)

### 전송률 제한
한 사용자가 받을 수 있는 알림의 빈도를 제한, 아예 꺼버릴 수도 있기 때문에

### 재시도 방법
써드파티가 알림 전송에 실패하면 재시도 전용 큐에 넣고, 같은 문제가 계속 발생하면 개발자에게 alert

### 보안
key, secret 을 사용하여 인증된 클라이언트만 api 사용할 수 있도록

### 큐 모니터링
큐에 쌓인 알림의 개수를 주의할 것. 수가 너무 크면 이벤트를 빠르게 처리하고 있지 못하다는 뜻 -> 작업 서버를 증설해야 함. 

### 이벤트 추적
알림 확인율, 클릭율, 실제 앱 사용 등을 보고 사용자를 이해할 수 있음. 





