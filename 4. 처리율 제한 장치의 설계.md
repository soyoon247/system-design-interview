# 4. 처리율 제한 장치의 설계
API 요청 횟수가 제한 장치에 정의된 임계치를 넘으면 추가로 도달한 모든 호출은 처리가 중단됨

### 방법

- 클라이언트에서 통제하기 -> 안정적 X
- 서버 측 미들웨어에서 통제하기 ex) API gateway
    
=> 상황에 맞는 처리율 제한 알고리즘을 찾아 직접 구현한다. 또는 충분한 인력이 없다면 상용 게이트웨이를 쓰는 것도 괜찮음


### 처리율 제한 알고리즘
    1. 토큰 버킷 알고리즘
    - 각 요청은 처리될 때마다 하나의 토큰을 사용하고, 충분한 토큰이 없는 경우, 해당 요청은 버려진다. 
    - 구현이 쉽고, 효율적이다. 짧은 시간에 집중되는 트래픽도 처리 가능.

    2. 누출 버킷 알고리즘
    - FIFO 큐에 빈자리가 있는 경우 큐에 요청을 추가하고, 지정된 시간마다 큐에서 요청을 꺼내어 처리, 큐가 가득 찬 경우 요청을 버린다.
    - 고정된 처리율로 안정적 출력 가능, 단시간에 트래픽이 몰리는 경우, 최신 요청들은 버려지게 된다. 
    
    3. 고정 윈도 카운터 알고리즘
    - 타임라인을 고정된 간격의 윈도로 나누고, 요청마다 카운터 값이 1 증가, 임계치에 도달하면 새로운 요청은 버려진다. 
    - 윈도의 경계 부근에서 트래픽이 몰려드는 경우, 요청이 예상 처리 한도보다 많아진다. 

    4. 이동 윈도 로깅 알고리즘
    - 요청의 타임스탬프를 남긴다. 새로운 요청을 기준으로 범위 안에 있는 요청을 카운트하여, 허용치를 넘지 않은 경우, 처리하고, 그렇지 않으면 버린다. 
    - 어느 순간을 봐도 처리율 한도를 넘지 않는 정교한 메커니즘, 하지만 메모리 사용이 크다.

    5. 이동 윈도 카운터 알고리즘
    - 고정 윈도 카운터 알고리즘 + 이동 윈도 로깅 알고리즘을 결합. 현재 고정 윈도 안의 요청 수 + 직전 고정 윈도 안의 요청 수 * 이동 윈도와 직전 고정 윈도가 겹치는 비율에 따라 처리한다
    - 메모리 효율이 좋고, 짧은 시간에 몰리는 트래픽에도 좋다. 
    - 추정치가 정확하지 않을 수 있지만, 크게 무리는 없음. 



### 아키텍처
- 핵심 로직 : 얼마나 많은 요청이 접수되었는지를 추적할 수 있는 카운터를 추적 대상별로 두고, 한도를 넘은 요청은 거부하는 것
- 카운터는 어디에? -> redis 같은 메모리 캐시 (빠르고, 만료 정책 지원)
- 클라이언트는 HTTP 응답 헤더를 통해 throttle을 감지할 수 있다 (429 too many requests with X-Ratelimit-Remaining, X-Ratelimit-Limit, X-Ratelimit-Retry-After )
- 처리율 제한 규칙을 디스크에 보관한뒤, 수시로 캐시에 저장 -> 캐시에서 제한 규칙 & 카운터 등을 가져옴 -> 알고리즘에 따라 요청을 처리 또는 폐기
- 분산환경에서의 문제 
    ```
    1. 경쟁 조건
    - 락을 통해서 해결 가능 but 성능 떨어짐 
    - 루아 스크립트, 정렬 집합 이용
    2. 동기화
    - 여러 대의 처리율 제한 장치를 둘 경우, 동기화가 필요. 
    - 레디스 같은 중앙 집중형 저장소를 사용하여 해결
    ```

- 모니터링을 통해 알고리즘이 효과적인지, 처리율 제한 규칙이 효과적인지 확인할 것. 

### 기타
클라이언트 설계는? 
- 클라이언트 측 캐시를 사용하여 API 호출 횟수를 줄이고, 예외 상황을 잘 처리하도록 한다. 
- 재시도 로직을 구현할 때는 충분한 back-off 시간을 둔다. 

