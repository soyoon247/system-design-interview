# 6. 키-값 저장소 설계
키-값 저장소 = 비 관계형 데이터베이스 ex)아마존 다이나모, memcached, 레디스 등

- 키는 유일하며, 값은 키를 통해서만 접근할 수 있다. 
- 읽기, 쓰기, 메모리 사용량 사이의 균형, 데이터의 일관성과 가용성 사이에서 타협적 결정을 내린 설계를 만들어야 한다. 

### 단일 서버 키-값 저장소
- 해시 테이블로 저장 -> 한계가 있음

### 분산 키-값 저장소(분산 해시 테이블)

#### CAP 정리
데이터 일관성(consistency), 가용성(availability), 파티션 감내(partition 
tolerance) 세 가지 요구사항을 동시에 만족하는 분산 시스템을 설계하는 것은 불가능하다는 정리

- consistency : 모든 클라이언트는 같은 데이터를 봐야 함
- availability : 일부 노드에 장애가 발생하더라도 응답을 받을 수 있어야 함
- partition tolerance : 네트워크에 파티션(통신 장애)가 생기더라도 시스템은 동작해야 함

-> 셋 중 두 가지를 만족해야 하는데, 네트워크 장애는 피할 수 없으므로, P는 반드시 만족시켜야 함(실세계에서 CA는 불가능) **일관성과 가용성 중에 하나를 선택해야 한다.**

ex) 은행이라면 계좌 정보 틀리면 안되므로, 일관성을 포기할 수 없음. -> 가용성을 포기

#### 시스템 컴포넌트
- 데이터 파티션 : 안정 해시를 통해 데이터를 적절한 파티션으로 나누어 저장

- 데이터 다중화 : 데이터를 N개 서버에 다중화하기 위해 안정 해시에서 링을 순회하며 만나는 N개의 서버에 데이터 사본을 저장하는 방식을 사용
- 일관성 

    정족수 합의 프로토콜을 사용하여 일관성 보장 (성공을 확신하기 위해 다른 서버로부터 확인이 얼마나 필요한지.
    ```
    N = 사본 개수, W = 쓰기 연산에 대한 정족수, R = 읽기 연산에 대한 정족수일 때,
    R = 1 -> 빠른 읽기
    W = 1 -> 빠른 쓰기
    W + R > N : 강한 일관성 
    ```
    강한 일관성 - 고가용성 X

    최종 일관성 : 강한 일관성은 아니지만, 결국에는 동기화되는 모델

- 비일관성 해소 기법 : 데이터 버저닝
    
    데이터를 다중화하면 가용성은 높아지지만 사본 간 일관성이 깨질 가능성은 높아진다. -> 버저닝, 벡터 시계를 사용하여 해결
    
    벡터 시계[서버, 버전] 의 순서쌍을 데이터에 매핑하여, 충돌을 확인한다. 
    데이터를 읽어보는데 충돌된 데이터인 경우, 이를 해소한 후 다시 서버에 기록한다. 
    -> 데이터를 읽어보는 클라이언트가 해소해야 되기 때문에 구현이 복잡해짐. 벡터 시계의 순서쌍 개수가 빠르게 늘어나서 오래된 순서쌍은 제거하도록 해야 함. 

- 장애 감지 : 보통 두 대 이상의 서버가 똑같이 장애를 보고해야 해당 서버에 장애가 발생했다고 간주하는데, 모든 노드가 서로를 확인하면 비효율적, 가십 프로토콜 이용

    가십 프로토콜(분산형 장애 감지 솔루션)
    - 각 노드가 멤버 - heartbeat counter 목록을 갖고 있고, 무작위로 선정된 노드들에게 자신의 목록을 보낸다. 목록을 받으면 최신 값으로 업데이트하고, 지정 시간 동안 갱신되지 않으면 해당 멤버를 장애로 간주한다. 

- 일시적 장애 처리 : 장애 상황에서는 느슨한 정족수 접근법으로 가용성을 높인다. 장애 상태인 서버로 가는 요청은 다른 서버가 맡아 처리하고, 그 동안의 변경사항은 힌트를 남겨두어, 이를 통해 나중에 반영할 수 있도록 한다. (hinted handoff)

- 영구 장애 처리 
    - 반-엔트로피 프로토콜을 통해 사본을 동기화. 
    - 머클 트리(자식 노드들의 값의 해시, 또는 그 자식 노드들의 레이블로 계산된 해시값을 레이블로 붙여두는 트리)를 사용하여, 모든 데이터를 동기화하는 것이 아니라, 실제로 차이가 있는 데이터만 동기화할 수 있게 된다. 



### 시스템 아키텍처
카산드라 예시
- 쓰기 요청 : 디스크에 저장, 캐시에 저장, 캐시에 저장할 수 없으면 디스크의 SSTable에 기록
- 읽기 요청 : 메모리 검사, 블룸 필터를 통해 어느 SSTable에 보관되어 있는지 검색 -> 데이터 가져온다

