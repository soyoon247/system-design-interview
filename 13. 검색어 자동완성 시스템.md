# 검색어 자동완성 시스템

## 트라이 자료 구조
- 질의문과 사용빈도를 저장하는 빈도 테이블 -> sql을 통해 질의한다면 병목이 된다. 
- 트라이(trie) = 접두어 트리 를 이용하는 것이 효율적
- 문자열들을 간략하게 저장할 수 있는 자료구조
    - 트리 형태
    - 빈 문자열인 루트 노드에서 시작하여 각 노드는 글자 하나를 저장, 26개의 자식 노드를 가질 수 있음 
    - 각 트리노드는 하나의 단어, 또는 접두어 문자열을 나타냄

- 가장 많이 사용된 질의어 k개를 찾을 때
    - 해당 접두어를 표현하는 노드를 찾는다. 시간 복잡도는 O(접두어의 길이)
    - 해당 노드의 하위 트리를 탐색하여 유효 노드(유효한 검색 문자열) 찾기 O(자식 노드 개수)
    - 유효 노드 정렬하여 인기 검색어 찾기 O(clogc, c: 자식 노드 개수)

- 최적화하기
    - 접두어의 최대 길이를 제한하면 O(작은 상숫값) = O(1)이 된다.
    - 각 노드에 인기 검색어를 캐시 -> O(1)

## 데이터 수집 서비스
- 입력한 질의를 실시간으로 수집하는 시스템
- 트위터같은 실시간 애플리케이션이 아니고, 구글 검색이라면 검색어를 자주 바꿔줄 필요가 없다. -> 갱신을 실시간으로 하지 않아도 됨.

### 데이터 분석 서비스 로그
- 새로운 데이터 추가될 뿐 수정하지 않는다. 

### 로그 취합 서버
- 데이터 취합하여 사용할 수 있도록 정리

### 작업 서버 
- 트라이 자료 구조 만들고 트라이 디비에 저장

### 트라이 캐시 
- 매주 트라이 디비의 스냅샷을 떠서 갱신

### 트라이 디비
- document store : 주기적으로 트라이를 직렬화하여 디비에 저장.
- 키-값 저장소 : 모든 접두어를 키로 변환, 노드의 데이터를 값으로 변환. 

## 질의 서비스
- 주어진 질의에 다섯 개의 인기 검색어를 정렬해 내놓는 서비스
- 로드밸런서 -> API 서버 -> 트라이 캐시에서 데이터를 가져와 응답 -> 없으면 트라이 디비에서 가져와서 응답, 캐시 저장
- 브라우저 캐싱, 데이터 샘플링 등의 방법으로 최적화 가능

## 트라이 연산

### 트라이 갱신
- 매주 한 번 새로운 트라이를 만들어서 기존 트라이를 대체한다. 
- 각 노드를 개별적으로 갱신한다. (트라이가 작을 때 해도 괜찮)

### 검색어 삭제
- 트라이 캐시 앞에 필터 계층을 두어 응답할 때 결과를 필터링
- 디비에서 삭제하는 것은 비동기적으로 진행

### 저장소 규모 확장
- 트라이의 크기가 너무 큰 경우
    - 첫 글자를 기준으로 샤딩(a-i까지 서버1, j-r까지 서버2)
- 검색어 대응 샤드 관리자 : 각 서버에 데이터가 균등하게 배분되지 않기 때문에 관리자를 통해 어떤 검색어가 어느 서버에 저장되는지 정보를 관리함. 

## 기타
### 다국어 지원
- 트라이에 유니코드를 저장
